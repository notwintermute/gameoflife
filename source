import math
import pygame
import numpy as np
import time

sqSide = 20
noSq = 30
sqRes = noSq * sqSide
resX = sqRes
resY = sqRes
n = noSq
fps = 10
playing = 0
time1 = time.time()
grid = np.zeros((n, n))  # grid where amount is stored

line2 = np.zeros((1, n))
line2[0, 0:2] = 1
aMul = line2
line3 = np.zeros((1, n + 1))
line3[0, 0:3] = 1
for i in range(n - 3):
    aMul = np.concatenate((aMul, line3), axis=1)
aMul = np.concatenate((aMul, np.ones((1, 3))), axis=1)
aMul = np.concatenate((aMul, np.zeros((1, n))), axis=1)
aMul[0, -1] = aMul[0, -2] = 1
aMul = aMul.reshape((n, n))


emitters = []
brushSize = 0
drawing = False
erasing = False
pygame.init()

# initialize surface and start the main loop
surface = pygame.display.set_mode((resX, resY))
pygame.display.set_caption('Game of Life')
running = True
# --------------------------------------- Main Loop ---------------------------------------
while running:
    mouse = pygame.mouse.get_pos()  # puts the mouse position into a 2d tuple
    mouseSq = [math.floor(mouse[0] / sqSide), math.floor(mouse[1] / sqSide)]
    # ------------------------------------- input handling -------------------------------------
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
            break
        # ------------------------------------ mouse click actions ------------------------------------
        if event.type == pygame.MOUSEBUTTONDOWN:
            if event.button == 1:
                drawing = True
            if event.button == 3:
                erasing = True
        if event.type == pygame.MOUSEBUTTONUP:  # releasing the hold
            drawing = False
            erasing = False
        # ------------------------------------ key press actions ------------------------------------
        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_s:
                playing += 1
                playing %= 2
            if event.key == pygame.K_e:
                sum = np.matmul(aMul, np.matmul(aMul, grid).transpose()).transpose() - grid
                s2 = (1 * (sum == 2))
                s3 = (1 * (sum == 3))
                live = 1 * ((grid + s2) == 2)
                grid = (s3 + live)

    # ---------------------------------------- Updating Parameters ----------------------------------------
    if drawing:
        grid[mouseSq[0], mouseSq[1]] = 1
    if erasing:
        grid[mouseSq[0], mouseSq[1]] = 0

    if time.time()-time1 > (1/fps) and playing:
        sum = np.matmul(aMul, np.matmul(aMul, grid).transpose()).transpose() - grid
        s2 = (1 * (sum == 2))
        s3 = (1 * (sum == 3))
        live = 1 * ((grid + s2) == 2)
        grid = (s3 + live)
        time1 = time.time()
    # ---------------------------------------- Rendering ----------------------------------------
    for x in range(noSq):
        for y in range(noSq):
            color = (255*grid[x, y], 255*grid[x, y], 255*grid[x, y])
            pygame.draw.rect(surface, color, (x * sqSide, y * sqSide, sqSide, sqSide))
            pygame.draw.rect(surface, (155, 155, 155), (x * sqSide, y * sqSide, sqSide, sqSide), width=1)


    pygame.display.flip()
